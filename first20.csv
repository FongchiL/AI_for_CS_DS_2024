status,paid_only,is_favor,frequency,progress,stat.question_id,stat.question__article__live,stat.question__article__slug,stat.question__article__has_video_solution,title,slug,is_hidden,total_accepted,total_submissions,id,stat.is_new_question,difficulty.level,ProblemDescription,num_solutions,num_likes,num_dislikes,Answer
,FALSE,FALSE,0,0,2714,,,,Left and Right Sum Differences,left-and-right-sum-differences,FALSE,35989,40611,2574,FALSE,1,"Can you solve this real interview question? Left and Right Sum Differences - Given a 0-indexed integer array nums, find a 0-indexed integer array answer where:

 * answer.length == nums.length.
 * answer[i] = |leftSum[i] - rightSum[i]|.

Where:

 * leftSum[i] is the sum of elements to the left of the index i in the array nums. If there is no such element, leftSum[i] = 0.
 * rightSum[i] is the sum of elements to the right of the index i in the array nums. If there is no such element, rightSum[i] = 0.

Return the array answer.

 

Example 1:


Input: nums = [10,4,8,3]
Output: [15,1,11,22]
Explanation: The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0].
The array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].


Example 2:


Input: nums = [1]
Output: [0]
Explanation: The array leftSum is [0] and the array rightSum is [0].
The array answer is [|0 - 0|] = [0].


 

Constraints:

 * 1 <= nums.length <= 1000
 * 1 <= nums[i] <= 105",Solutions (696),347,18,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:
        n = len(nums)
        left_sum = [0] * n
        right_sum = [0] * n
        left_sum[0] = nums[0]
        right_sum[-1] = nums[-1]
        for i in range(1, n):
            left_sum[i] = left_sum[i - 1] + nums[i]
        for i in range(n - 2, -1, -1):
            right_sum[i] = right_sum[i + 1] + nums[i]
        answer = [0] * n
        for i in range(n):
            if i == 0:
                answer[i] = abs(right_sum[i + 1])
            elif i == n - 1:
                answer[i] = abs(left_sum[i - 1])
            else:
                answer[i] = abs(left_sum[i - 1] - right_sum[i + 1])
        return answer"
,FALSE,FALSE,0,0,2713,,,,Find the Divisibility Array of a String,find-the-divisibility-array-of-a-string,FALSE,19189,61985,2575,FALSE,2,"Can you solve this real interview question? Find the Divisibility Array of a String - You are given a 0-indexed string word of length n consisting of digits, and a positive integer m.

The divisibility array div of word is an integer array of length n such that:

 * div[i] = 1 if the numeric value of word[0,...,i] is divisible by m, or
 * div[i] = 0 otherwise.

Return the divisibility array of word.

 

Example 1:


Input: word = ""998244353"", m = 3
Output: [1,1,0,0,0,1,1,0,0]
Explanation: There are only 4 prefixes that are divisible by 3: ""9"", ""99"", ""998244"", and ""9982443"".


Example 2:


Input: word = ""1010"", m = 10
Output: [0,1,0,1]
Explanation: There are only 2 prefixes that are divisible by 10: ""10"", and ""1010"".


 

Constraints:

 * 1 <= n <= 105
 * word.length == n
 * word consists of digits from 0 to 9
 * 1 <= m <= 109",Solutions (284),373,13,"class Solution:
    def getDivArray(self, word: str, m: int) -> List[int]:
        n = len(word)
        prefix = 0
        res = []
        for i in range(n):
            prefix = (prefix * 10 + int(word[i])) % m
            res.append(prefix == 0)
        return res"
,FALSE,FALSE,0,0,2712,,,,Find the Maximum Number of Marked Indices,find-the-maximum-number-of-marked-indices,FALSE,13611,36348,2576,FALSE,2,"Can you solve this real interview question? Find the Maximum Number of Marked Indices - You are given a 0-indexed integer array nums.

Initially, all of the indices are unmarked. You are allowed to make this operation any number of times:

 * Pick two different unmarked indices i and j such that 2 * nums[i] <= nums[j], then mark i and j.

Return the maximum possible number of marked indices in nums using the above operation any number of times.

 

Example 1:


Input: nums = [3,5,2,4]
Output: 2
Explanation: In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] <= nums[1]. Then mark index 2 and 1.
It can be shown that there's no other valid operation so the answer is 2.


Example 2:


Input: nums = [9,2,5,4]
Output: 4
Explanation: In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] <= nums[0]. Then mark index 3 and 0.
In the second operation: pick i = 1 and j = 2, the operation is allowed because 2 * nums[1] <= nums[2]. Then mark index 1 and 2.
Since there is no other operation, the answer is 4.


Example 3:


Input: nums = [7,6,8]
Output: 0
Explanation: There is no valid operation to do, so the answer is 0.



 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 109

 ",Solutions (258),394,19,"class Solution:
    def maxMarkedNums(self, nums: List[int]) -> int:
        nums.sort()
        l, r = 0, len(nums) - 1
        res = 0
        while l < r:
            if 2 * nums[l] <= nums[r]:
                res += 1
                l += 1
                r -= 1
            else:
                r -= 1
        return res"
,FALSE,FALSE,0,0,2711,,,,Minimum Time to Visit a Cell In a Grid,minimum-time-to-visit-a-cell-in-a-grid,FALSE,6102,17157,2577,FALSE,3,"Can you solve this real interview question? Minimum Time to Visit a Cell In a Grid - You are given a m x n matrix grid consisting of non-negative integers where grid[row][col] represents the minimum time required to be able to visit the cell (row, col), which means you can visit the cell (row, col) only when the time you visit it is greater than or equal to grid[row][col].

You are standing in the top-left cell of the matrix in the 0th second, and you must move to any adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.

Return the minimum time required in which you can visit the bottom-right cell of the matrix. If you cannot visit the bottom-right cell, then return -1.

 

Example 1:

[https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png]


Input: grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]
Output: 7
Explanation: One of the paths that we can take is the following:
- at t = 0, we are on the cell (0,0).
- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] <= 1.
- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] <= 2.
- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] <= 3.
- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] <= 4.
- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] <= 5.
- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] <= 6.
- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] <= 7.
The final time is 7. It can be shown that it is the minimum time possible.


Example 2:

[https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png]


Input: grid = [[0,2,4],[3,2,1],[1,0,4]]
Output: -1
Explanation: There is no path from the top left to the bottom-right cell.


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 2 <= m, n <= 1000
 * 4 <= m * n <= 105
 * 0 <= grid[i][j] <= 105
 * grid[0][0] == 0

 ",Solutions (114),336,6,"class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        directions = [(0,1),(1,0),(-1,0),(0,-1)]
        m, n = len(heights), len(heights[0])
        pq = [(0,0,0)]
        cost = [[float(""inf"")] * n for _ in range(m)]
        cost[0][0] = 0
        
        while pq:
            curr_cost, row, col = heapq.heappop(pq)
            if row == m-1 and col == n-1:
                return curr_cost
            for dr, dc in directions:
                new_row, new_col = row+dr, col+dc
                if 0 <= new_row < m and 0 <= new_col < n:
                    new_cost = max(curr_cost, abs(heights[row][col] - heights[new_row][new_col]))
                    if new_cost < cost[new_row][new_col]:
                        cost[new_row][new_col] = new_cost
                        heapq.heappush(pq, (new_cost, new_row, new_col))
        
        return -1"
,FALSE,FALSE,0,0,2710,,,,Minimum Operations to Reduce an Integer to 0,minimum-operations-to-reduce-an-integer-to-0,FALSE,15032,30312,2571,FALSE,2,"Can you solve this real interview question? Minimum Operations to Reduce an Integer to 0 - You are given a positive integer n, you can do the following operation any number of times:

 * Add or subtract a power of 2 from n.

Return the minimum number of operations to make n equal to 0.

A number x is power of 2 if x == 2i where i >= 0.

 

Example 1:


Input: n = 39
Output: 3
Explanation: We can do the following operations:
- Add 20 = 1 to n, so now n = 40.
- Subtract 23 = 8 from n, so now n = 32.
- Subtract 25 = 32 from n, so now n = 0.
It can be shown that 3 is the minimum number of operations we need to make n equal to 0.


Example 2:


Input: n = 54
Output: 3
Explanation: We can do the following operations:
- Add 21 = 2 to n, so now n = 56.
- Add 23 = 8 to n, so now n = 64.
- Subtract 26 = 64 from n, so now n = 0.
So the minimum number of operations is 3.


 

Constraints:

 * 1 <= n <= 105",Solutions (423),323,175,"class Solution:
    def minOperations(self, n: int) -> int:
        ans = 0
        while n:
            ans += n & 1
            n >>= 1
        return ans - 1"
,FALSE,FALSE,0,0,2709,,,,Count the Number of Square-Free Subsets,count-the-number-of-square-free-subsets,FALSE,4711,23178,2572,FALSE,2,"Can you solve this real interview question? Count the Number of Square-Free Subsets - You are given a positive integer 0-indexed array nums.

A subset of the array nums is square-free if the product of its elements is a square-free integer.

A square-free integer is an integer that is divisible by no square number other than 1.

Return the number of square-free non-empty subsets of the array nums. Since the answer may be too large, return it modulo 109 + 7.

A non-empty subset of nums is an array that can be obtained by deleting some (possibly none but not all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.

 

Example 1:


Input: nums = [3,4,4,5]
Output: 3
Explanation: There are 3 square-free subsets in this example:
- The subset consisting of the 0th element [3]. The product of its elements is 3, which is a square-free integer.
- The subset consisting of the 3rd element [5]. The product of its elements is 5, which is a square-free integer.
- The subset consisting of 0th and 3rd elements [3,5]. The product of its elements is 15, which is a square-free integer.
It can be proven that there are no more than 3 square-free subsets in the given array.

Example 2:


Input: nums = [1]
Output: 1
Explanation: There is 1 square-free subset in this example:
- The subset consisting of the 0th element [1]. The product of its elements is 1, which is a square-free integer.
It can be proven that there is no more than 1 square-free subset in the given array.


 

Constraints:

 * 1 <= nums.length <= 1000
 * 1 <= nums[i] <= 30",Solutions (89),252,93,"class Solution:
    def countSquareSumsets(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        MAX_PROD = 30 * 30 * 30 * 30 * 3
        
        def gcd(a, b):
            return gcd(b, a % b) if b else a
        
        def lcm(a, b):
            return a * b // gcd(a, b)
        
        freq = [0] * (max(nums) + 1)
        for num in nums:
            freq[num] += 1
        
        ans = 0
        for prod in range(1, MAX_PROD + 1):
            mu = [0] * (max(nums) + 1)
            for num in range(1, len(mu)):
                if num * num > prod:
                    break
                if prod % (num * num) == 0:
                    mu[num] = 0
                else:
                    mu[num] = (-1)**freq[num]
            for num in range(1, len(mu)):
                for factor in range(2, len(mu)):
                    if num * factor > max(nums):
                        break
                    mu[num * factor] += mu[num]
            sub_ans = 1
            for num in range(1, len(mu)):
                if mu[num] == 0:
                    continue
                count = freq[num]
                sub_ans *= (2**mu[num] - 1)**count
            ans += sub_ans
        return ans % MOD"
,FALSE,FALSE,0,0,2708,,,,Find the String with LCP,find-the-string-with-lcp,FALSE,2801,7804,2573,FALSE,3,"Can you solve this real interview question? Find the String with LCP - We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:

 * lcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].

Given an n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.

A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, ""aabd"" is lexicographically smaller than ""aaca"" because the first position they differ is at the third letter, and 'b' comes before 'c'.

 

Example 1:


Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]
Output: ""abab""
Explanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is ""abab"".


Example 2:


Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]
Output: ""aaaa""
Explanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is ""aaaa"". 


Example 3:


Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]
Output: """"
Explanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists.


 

Constraints:

 * 1 <= n == lcp.length == lcp[i].length <= 1000
 * 0 <= lcp[i][j] <= n",Solutions (46),121,10,"class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        def find(x):
            while x != uf[x]:
                uf[x], x = uf[uf[x]], uf[x]
            return x
        
        n = len(s)
        uf = list(range(n))
        for a, b in pairs:
            ua, ub = find(a), find(b)
            if ua != ub: uf[ua] = ub
        
        d = defaultdict(list)
        for i in range(n):
            d[find(i)].append(i)
        
        ans = list(s)
        for group in d.values():
            group_chars = sorted(ans[i] for i in group)
            for i, c in zip(group, group_chars):
                ans[i] = c
        
        return ''.join(ans)"
,FALSE,FALSE,0,0,2707,,,,Merge Two 2D Arrays by Summing Values,merge-two-2d-arrays-by-summing-values,FALSE,22313,30488,2570,FALSE,1,"Can you solve this real interview question? Merge Two 2D Arrays by Summing Values - You are given two 2D integer arrays nums1 and nums2.

 * nums1[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.
 * nums2[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.

Each array contains unique ids and is sorted in ascending order by id.

Merge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:

 * Only ids that appear in at least one of the two arrays should be included in the resulting array.
 * Each id should be included only once and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be 0.

Return the resulting array. The returned array must be sorted in ascending order by id.

 

Example 1:


Input: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]
Output: [[1,6],[2,3],[3,2],[4,6]]
Explanation: The resulting array contains the following:
- id = 1, the value of this id is 2 + 4 = 6.
- id = 2, the value of this id is 3.
- id = 3, the value of this id is 2.
- id = 4, the value of this id is 5 + 1 = 6.


Example 2:


Input: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]
Output: [[1,3],[2,4],[3,6],[4,3],[5,5]]
Explanation: There are no common ids, so we just include each id with its value in the resulting list.


 

Constraints:

 * 1 <= nums1.length, nums2.length <= 200
 * nums1[i].length == nums2[j].length == 2
 * 1 <= idi, vali <= 1000
 * Both arrays contain unique ids.
 * Both arrays are in strictly ascending order by id.",Solutions (393),181,6,"class Solution:
    def merge(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:
        ids = set()
        for num in nums1:
            ids.add(num[0])
        for num in nums2:
            ids.add(num[0])
        res = []
        for i in sorted(ids):
            sum_val = 0
            for num in nums1:
                if num[0] == i:
                    sum_val += num[1]
            for num in nums2:
                if num[0] == i:
                    sum_val += num[1]
            res.append([i, sum_val])
        return res"
,FALSE,FALSE,0,0,2706,,,,Minimum Score by Changing Two Elements,minimum-score-by-changing-two-elements,FALSE,12618,26514,2567,FALSE,2,"Can you solve this real interview question? Minimum Score by Changing Two Elements - You are given a 0-indexed integer array nums.

 * The low score of nums is the minimum value of |nums[i] - nums[j]| over all 0 <= i < j < nums.length.
 * The high score of nums is the maximum value of |nums[i] - nums[j]| over all 0 <= i < j < nums.length.
 * The score of nums is the sum of the high and low scores of nums.

To minimize the score of nums, we can change the value of at most two elements of nums.

Return the minimum possible score after changing the value of at most two elements of nums.

Note that |x| denotes the absolute value of x.

 

Example 1:


Input: nums = [1,4,3]
Output: 0
Explanation: Change value of nums[1] and nums[2] to 1 so that nums becomes [1,1,1]. Now, the value of |nums[i] - nums[j]| is always equal to 0, so we return 0 + 0 = 0.


Example 2:


Input: nums = [1,4,7,8,5]
Output: 3
Explanation: Change nums[0] and nums[1] to be 6. Now nums becomes [6,6,7,8,5].
Our low score is achieved when i = 0 and j = 1, in which case |nums[i] - nums[j]| = |6 - 6| = 0.
Our high score is achieved when i = 3 and j = 4, in which case |nums[i] - nums[j]| = |8 - 5| = 3.
The sum of our high and low score is 3, which we can prove to be minimal.


 

Constraints:

 * 3 <= nums.length <= 105
 * 1 <= nums[i] <= 109",Solutions (185),149,157,"class Solution:
    def minDifference(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        if n <= 4:
            return 0
        return min(nums[-1]-nums[3], nums[-2]-nums[2], nums[-3]-nums[1], nums[-4]-nums[0])"
,FALSE,FALSE,0,0,2705,,,,Minimum Impossible OR,minimum-impossible-or,FALSE,10966,19105,2568,FALSE,2,"Can you solve this real interview question? Minimum Impossible OR - You are given a 0-indexed integer array nums.

We say that an integer x is expressible from nums if there exist some integers 0 <= index1 < index2 < ... < indexk < nums.length for which nums[index1] | nums[index2] | ... | nums[indexk] = x. In other words, an integer is expressible if it can be written as the bitwise OR of some subsequence of nums.

Return the minimum positive non-zero integer that is not expressible from nums.

 

Example 1:


Input: nums = [2,1]
Output: 4
Explanation: 1 and 2 are already present in the array. We know that 3 is expressible, since nums[0] | nums[1] = 2 | 1 = 3. Since 4 is not expressible, we return 4.


Example 2:


Input: nums = [5,3,2]
Output: 1
Explanation: We can show that 1 is the smallest number that is not expressible.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 109",Solutions (172),246,14,"class Solution:
    def minNonzero(self, nums: List[int]) -> int:
        mod = 10**9 + 7
        n = len(nums)
        p = pow(2, n) - 1
        q = pow(2, n-1)
        ans = pow(2, p, mod) * (pow(2, q, mod) - 1) % mod
        return ans"
,FALSE,FALSE,0,0,2704,,,,Maximum Difference by Remapping a Digit,maximum-difference-by-remapping-a-digit,FALSE,17562,29146,2566,FALSE,1,"Can you solve this real interview question? Maximum Difference by Remapping a Digit - You are given an integer num. You know that Danny Mittal will sneakily remap one of the 10 possible digits (0 to 9) to another digit.

Return the difference between the maximum and minimum values Danny can make by remapping exactly one digit in num.

Notes:

 * When Danny remaps a digit d1 to another digit d2, Danny replaces all occurrences of d1 in num with d2.
 * Danny can remap a digit to itself, in which case num does not change.
 * Danny can remap different digits for obtaining minimum and maximum values respectively.
 * The resulting number after remapping can contain leading zeroes.
 * We mentioned ""Danny Mittal"" to congratulate him on being in the top 10 in Weekly Contest 326.

 

Example 1:


Input: num = 11891
Output: 99009
Explanation: 
To achieve the maximum value, Danny can remap the digit 1 to the digit 9 to yield 99899.
To achieve the minimum value, Danny can remap the digit 1 to the digit 0, yielding 890.
The difference between these two numbers is 99009.


Example 2:


Input: num = 90
Output: 99
Explanation:
The maximum value that can be returned by the function is 99 (if 0 is replaced by 9) and the minimum value that can be returned by the function is 0 (if 9 is replaced by 0).
Thus, we return 99.

 

Constraints:

 * 1 <= num <= 108",Solutions (260),155,30,"class Solution:
    def maxDiff(self, num: int) -> int:
        s = str(num)
        max_num = int(s.replace(max(s), '9'))
        min_num = int(s.replace('1' if s[0] != '1' else '0', '1'))
        return max_num - min_num"
,FALSE,FALSE,0,0,2703,,,,Handling Sum Queries After Update,handling-sum-queries-after-update,FALSE,3139,12122,2569,FALSE,3,"Can you solve this real interview question? Handling Sum Queries After Update - You are given two 0-indexed arrays nums1 and nums2 and a 2D array queries of queries. There are three types of queries:

 1. For a query of type 1, queries[i] = [1, l, r]. Flip the values from 0 to 1 and from 1 to 0 in nums1 from index l to index r. Both l and r are 0-indexed.
 2. For a query of type 2, queries[i] = [2, p, 0]. For every index 0 <= i < n, set nums2[i] = nums2[i] + nums1[i] * p.
 3. For a query of type 3, queries[i] = [3, 0, 0]. Find the sum of the elements in nums2.

Return an array containing all the answers to the third type queries.

 

Example 1:


Input: nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]
Output: [3]
Explanation: After the first query nums1 becomes [1,1,1]. After the second query, nums2 becomes [1,1,1], so the answer to the third query is 3. Thus, [3] is returned.


Example 2:


Input: nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]
Output: [5]
Explanation: After the first query, nums2 remains [5], so the answer to the second query is 5. Thus, [5] is returned.


 

Constraints:

 * 1 <= nums1.length,nums2.length <= 105
 * nums1.length = nums2.length
 * 1 <= queries.length <= 105
 * queries[i].length = 3
 * 0 <= l <= r <= nums1.length - 1
 * 0 <= p <= 106
 * 0 <= nums1[i] <= 1
 * 0 <= nums2[i] <= 109",Solutions (71),127,22,"class Solution:
    def solve(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        res = []
        for q in queries:
            if q[0] == 1:
                for i in range(q[1], q[2]+1):
                    nums1[i] = 1 - nums1[i]
            elif q[0] == 2:
                p = q[1]
                for i in range(len(nums1)):
                    nums2[i] += nums1[i] * p
            elif q[0] == 3:
                res.append(sum(nums2))
        return res"
,FALSE,FALSE,0,0,2701,,,,Subsequence With the Minimum Score,subsequence-with-the-minimum-score,FALSE,4389,13636,2565,FALSE,3,"Can you solve this real interview question? Subsequence With the Minimum Score - You are given two strings s and t.

You are allowed to remove any number of characters from the string t.

The score of the string is 0 if no characters are removed from the string t, otherwise:

 * Let left be the minimum index among all removed characters.
 * Let right be the maximum index among all removed characters.

Then the score of the string is right - left + 1.

Return the minimum possible score to make t a subsequence of s.

A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., ""ace"" is a subsequence of ""abcde"" while ""aec"" is not).

 

Example 1:


Input: s = ""abacaba"", t = ""bzaa""
Output: 1
Explanation: In this example, we remove the character ""z"" at index 1 (0-indexed).
The string t becomes ""baa"" which is a subsequence of the string ""abacaba"" and the score is 1 - 1 + 1 = 1.
It can be proven that 1 is the minimum score that we can achieve.


Example 2:


Input: s = ""cde"", t = ""xyz""
Output: 3
Explanation: In this example, we remove characters ""x"", ""y"" and ""z"" at indices 0, 1, and 2 (0-indexed).
The string t becomes """" which is a subsequence of the string ""cde"" and the score is 2 - 0 + 1 = 3.
It can be proven that 3 is the minimum score that we can achieve.


 

Constraints:

 * 1 <= s.length, t.length <= 105
 * s and t consist of only lowercase English letters.",Solutions (84),275,5,"class Solution:
    def minScore(self, s: str, t: str) -> int:
        n, m = len(s), len(t)
        dp = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]
        for i in range(n + 1):
            dp[i][0] = 0
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if s[i - 1] == t[j - 1]:
                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1] + 1)
                else:
                    dp[i][j] = dp[i - 1][j]
        res = float('inf')
        for j in range(1, m + 1):
            i = dp[n][j]
            if i != float('inf'):
                res = min(res, j - i + 1)
        return res if res != float('inf') else -1"
,FALSE,FALSE,0,0,2700,,,,Substring XOR Queries,substring-xor-queries,FALSE,9397,28050,2564,FALSE,2,"Can you solve this real interview question? Substring XOR Queries - You are given a binary string s, and a 2D integer array queries where queries[i] = [firsti, secondi].

For the ith query, find the shortest substring of s whose decimal value, val, yields secondi when bitwise XORed with firsti. In other words, val ^ firsti == secondi.

The answer to the ith query is the endpoints (0-indexed) of the substring [lefti, righti] or [-1, -1] if no such substring exists. If there are multiple answers, choose the one with the minimum lefti.

Return an array ans where ans[i] = [lefti, righti] is the answer to the ith query.

A substring is a contiguous non-empty sequence of characters within a string.

 

Example 1:


Input: s = ""101101"", queries = [[0,5],[1,2]]
Output: [[0,2],[2,3]]
Explanation: For the first query the substring in range [0,2] is ""101"" which has a decimal value of 5, and 5 ^ 0 = 5, hence the answer to the first query is [0,2]. In the second query, the substring in range [2,3] is ""11"", and has a decimal value of 3, and 3 ^ 1 = 2. So, [2,3] is returned for the second query. 



Example 2:


Input: s = ""0101"", queries = [[12,8]]
Output: [[-1,-1]]
Explanation: In this example there is no substring that answers the query, hence [-1,-1] is returned.


Example 3:


Input: s = ""1"", queries = [[4,5]]
Output: [[0,0]]
Explanation: For this example, the substring in range [0,0] has a decimal value of 1, and 1 ^ 4 = 5. So, the answer is [0,0].


 

Constraints:

 * 1 <= s.length <= 104
 * s[i] is either '0' or '1'.
 * 1 <= queries.length <= 105
 * 0 <= firsti, secondi <= 109",Solutions (146),279,69,"class Trie:
    class Node:
        def __init__(self):
            self.children = [None, None]
            self.index = float('inf')

    def __init__(self, s):
        n = len(s)
        self.root = self.Node()
        self.root.index = -1
        pre = 0
        for i in range(n):
            pre = pre ^ (1 << (ord(s[i]) - 48))
            cur = self.root
            cur.index = min(cur.index, i)
            for j in range(31, -1, -1):
                bit = (pre >> j) & 1
                if not cur.children[bit]:
                    cur.children[bit] = self.Node()
                cur = cur.children[bit]
                cur.index = min(cur.index, i)

    def get_min_index(self, xor_val, start_idx):
        cur = self.root
        if cur.index > start_idx:
            return (-1, -1)
        pre = 0
        for i in range(31, -1, -1):
            bit = (xor_val >> i) & 1
            req_bit = 1 - bit
            if cur.children[req_bit] and cur.children[req_bit].index <= start_idx:
                cur = cur.children[req_bit]
                pre |= (req_bit << i)
            else:
                cur = cur.children[bit]
                pre |= (bit << i)
        return (cur.index, start_idx) if cur.index <= start_idx else (-1, -1)

class Solution:
    def __init__(self):
        self.s = None
        self.trie = None

    def xorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:
        self.s = s
        self.trie = Trie(self.s)
        res = []
        for query in queries:
            left, right = self.trie.get_min_index(query[0] ^ query[1], query[0])
            res.append([left, right])
        return res"
,FALSE,FALSE,0,0,2699,,,,Count the Number of Fair Pairs,count-the-number-of-fair-pairs,FALSE,16667,52161,2563,FALSE,2,"Can you solve this real interview question? Count the Number of Fair Pairs - Given a 0-indexed integer array nums of size n and two integers lower and upper, return the number of fair pairs.

A pair (i, j) is fair if:

 * 0 <= i < j < n, and
 * lower <= nums[i] + nums[j] <= upper

 

Example 1:


Input: nums = [0,1,7,4,4,5], lower = 3, upper = 6
Output: 6
Explanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).


Example 2:


Input: nums = [1,7,9,2,5], lower = 11, upper = 11
Output: 1
Explanation: There is a single fair pair: (2,3).


 

Constraints:

 * 1 <= nums.length <= 105
 * nums.length == n
 * -109 <= nums[i] <= 109
 * -109 <= lower <= upper <= 109",Solutions (255),570,16,"class Solution:
    def countPairs(self, nums: List[int], lower: int, upper: int) -> int:
        def merge_sort(l, r):
            if r - l <= 1:
                return 0
                
            mid = (l + r) // 2
            cnt = merge_sort(l, mid) + merge_sort(mid, r)
            
            i, j = l, mid
            k = 0
            tmp = [0] * (r - l)
            
            while i < mid:
                while j < r and nums[j] - nums[i] < lower:
                    j += 1
                
                lft = j
                while j < r and nums[j] - nums[i] <= upper:
                    j += 1
                
                cnt += j - lft
                
                while k < r - l and nums[k+l] < nums[i]:
                    tmp[k] = nums[k+l]
                    k += 1
                
                tmp[k] = nums[i]
                k += 1
                i += 1
            
            while k < r - l and j < r:
                if nums[j] < tmp[k]:
                    tmp[k] = nums[j]
                    cnt += mid - i
                    k += 1
                    j += 1
                else:
                    tmp[k] = nums[k+l]
                    k += 1
            
            while k < r - l:
                tmp[k] = nums[k+l]
                k += 1
                
            nums[l:r] = tmp
                
            return cnt
        
        return merge_sort(0, len(nums))"
,FALSE,FALSE,0,0,2698,,,,Find the Array Concatenation Value,find-the-array-concatenation-value,FALSE,28406,40690,2562,FALSE,1,"Can you solve this real interview question? Find the Array Concatenation Value - You are given a 0-indexed integer array nums.

The concatenation of two numbers is the number formed by concatenating their numerals.

 * For example, the concatenation of 15, 49 is 1549.

The concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:

 * If there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.
 * If one element exists, add its value to the concatenation value of nums, then delete it.

Return the concatenation value of the nums.

 

Example 1:


Input: nums = [7,52,2,4]
Output: 596
Explanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.
 - In the first operation:
We pick the first element, 7, and the last element, 4.
Their concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.
Then we delete them from nums, so nums becomes equal to [52,2].
 - In the second operation:
We pick the first element, 52, and the last element, 2.
Their concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.
Then we delete them from the nums, so nums becomes empty.
Since the concatenation value is 596 so the answer is 596.


Example 2:


Input: nums = [5,14,13,8,12]
Output: 673
Explanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.
 - In the first operation:
We pick the first element, 5, and the last element, 12.
Their concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.
Then we delete them from the nums, so nums becomes equal to [14,13,8].
 - In the second operation:
We pick the first element, 14, and the last element, 8.
Their concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.
Then we delete them from the nums, so nums becomes equal to [13].
 - In the third operation:
nums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.
Then we delete it from nums, so nums become empty.
Since the concatenation value is 673 so the answer is 673.


 

Constraints:

 * 1 <= nums.length <= 1000
 * 1 <= nums[i] <= 104

 ",Solutions (511),213,5,"class Solution:
    def getConcatenation(self, nums: List[int]) -> int:
        res = 0
        while nums:
            if len(nums) > 1:
                res += int(str(nums[0]) + str(nums[-1]))
                nums.pop(0)
                nums.pop(-1)
            else:
                res += nums[0]
                nums.pop(0)
        return res"
,FALSE,FALSE,0,0,2696,,,,The Number of Beautiful Subsets,the-number-of-beautiful-subsets,FALSE,9700,34672,2597,FALSE,2,"Can you solve this real interview question? The Number of Beautiful Subsets - You are given an array nums of positive integers and a positive integer k.

A subset of nums is beautiful if it does not contain two integers with an absolute difference equal to k.

Return the number of non-empty beautiful subsets of the array nums.

A subset of nums is an array that can be obtained by deleting some (possibly none) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.

 

Example 1:


Input: nums = [2,4,6], k = 2
Output: 4
Explanation: The beautiful subsets of the array nums are: [2], [4], [6], [2, 6].
It can be proved that there are only 4 beautiful subsets in the array [2,4,6].


Example 2:


Input: nums = [1], k = 1
Output: 1
Explanation: The beautiful subset of the array nums is [1].
It can be proved that there is only 1 beautiful subset in the array [1].


 

Constraints:

 * 1 <= nums.length <= 20
 * 1 <= nums[i], k <= 1000",Solutions (183),314,80,"class Solution:
    def countNicePairs(self, nums: List[int]) -> int:
        freq = collections.Counter(num - int(str(num)[::-1]) for num in nums)
        return sum(val * (val - 1) // 2 for val in freq.values()) % (10**9 + 7)"
,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,